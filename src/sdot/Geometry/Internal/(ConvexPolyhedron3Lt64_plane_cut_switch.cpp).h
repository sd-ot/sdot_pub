static void *dispatch_table[] = {
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_1,
    &&case_2,
    &&case_3,
    &&case_4,
    &&case_5,
    &&case_6,
    &&case_7,
    &&case_8,
    &&case_1,
    &&case_9,
    &&case_10,
    &&case_11,
    &&case_12,
    &&case_0,
    &&case_13,
    &&case_14,
    &&case_15,
    &&case_16,
    &&case_0,
    &&case_17,
    &&case_18,
    &&case_19,
    &&case_20,
    &&case_8,
    &&case_1,
    &&case_21,
    &&case_22,
    &&case_23,
    &&case_24,
    &&case_0,
    &&case_25,
    &&case_26,
    &&case_27,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_28,
    &&case_0,
    &&case_29,
    &&case_30,
    &&case_31,
    &&case_32,
    &&case_0,
    &&case_33,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_34,
    &&case_35,
    &&case_36,
    &&case_0,
    &&case_37,
    &&case_38,
    &&case_39,
    &&case_40,
    &&case_8,
    &&case_1,
    &&case_41,
    &&case_42,
    &&case_43,
    &&case_44,
    &&case_0,
    &&case_45,
    &&case_46,
    &&case_47,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_48,
    &&case_0,
    &&case_49,
    &&case_50,
    &&case_51,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_52,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_53,
    &&case_0,
    &&case_54,
    &&case_55,
    &&case_56,
    &&case_57,
    &&case_0,
    &&case_58,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_59,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_60,
    &&case_61,
    &&case_62,
    &&case_0,
    &&case_63,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_64,
    &&case_65,
    &&case_66,
    &&case_0,
    &&case_67,
    &&case_68,
    &&case_69,
    &&case_70,
    &&case_8,
    &&case_1,
    &&case_71,
    &&case_72,
    &&case_73,
    &&case_74,
    &&case_0,
    &&case_75,
    &&case_76,
    &&case_77,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_78,
    &&case_0,
    &&case_79,
    &&case_80,
    &&case_81,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_82,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_83,
    &&case_0,
    &&case_84,
    &&case_85,
    &&case_86,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_87,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_88,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_89,
    &&case_0,
    &&case_90,
    &&case_91,
    &&case_92,
    &&case_93,
    &&case_0,
    &&case_94,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_95,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_96,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_97,
    &&case_98,
    &&case_99,
    &&case_0,
    &&case_100,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_101,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_102,
    &&case_103,
    &&case_104,
    &&case_0,
    &&case_105,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_106,
    &&case_107,
    &&case_108,
    &&case_0,
    &&case_109,
    &&case_110,
    &&case_111,
    &&case_112,
    &&case_8,
    &&case_1,
    &&case_113,
    &&case_114,
    &&case_115,
    &&case_116,
    &&case_0,
    &&case_117,
    &&case_118,
    &&case_119,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_120,
    &&case_0,
    &&case_121,
    &&case_122,
    &&case_123,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_124,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_125,
    &&case_0,
    &&case_126,
    &&case_127,
    &&case_128,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_129,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_130,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_131,
    &&case_0,
    &&case_132,
    &&case_133,
    &&case_134,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_135,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_136,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_137,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_138,
    &&case_0,
    &&case_139,
    &&case_140,
    &&case_141,
    &&case_142,
    &&case_0,
    &&case_143,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_144,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_145,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_146,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_147,
    &&case_148,
    &&case_149,
    &&case_0,
    &&case_150,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_151,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_152,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_153,
    &&case_154,
    &&case_155,
    &&case_0,
    &&case_156,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_157,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_158,
    &&case_159,
    &&case_160,
    &&case_0,
    &&case_161,
    &&case_0,
    &&case_0,
    &&case_0,
    &&case_162,
    &&case_163,
    &&case_164,
    &&case_0,
    &&case_165,
    &&case_166,
    &&case_167,
    &&case_168,
    &&case_8,
};
goto *dispatch_table[ ouf ];
case_1: {
    // all_inside
    return;
}
case_2: {
    // n=3 00000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_192 = std::min( num_node_2, num_node_0 );
    int max_node_192 = std::max( num_node_2, num_node_0 );
    int num_edge_192 = 64 * max_node_192 + min_node_192;
    int num_node_192;
    if ( edge_num_cut_procs[ num_edge_192 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_192 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_192;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_192 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_192 ] = num_cut_proc;
        edge_cuts[ num_edge_192 ] = num_node_192;
    } else
        num_node_192 = edge_cuts[ num_edge_192 ];
    prev_cut_nodes[ num_node_128 ] = num_node_192;
    last_cut_node = num_node_128;
    // 128,1,2,192
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 3 ] = num_node_192;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_192 ) ;
    return;
}
case_3: {
    // n=3 00000010
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_193 ] = num_node_128;
    last_cut_node = num_node_193;
    // 0,128,193,2
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_2;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) ;
    return;
}
case_4: {
    // n=3 00000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_192 = std::min( num_node_2, num_node_0 );
    int max_node_192 = std::max( num_node_2, num_node_0 );
    int num_edge_192 = 64 * max_node_192 + min_node_192;
    int num_node_192;
    if ( edge_num_cut_procs[ num_edge_192 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_192 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_192;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_192 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_192 ] = num_cut_proc;
        edge_cuts[ num_edge_192 ] = num_node_192;
    } else
        num_node_192 = edge_cuts[ num_edge_192 ];
    prev_cut_nodes[ num_node_193 ] = num_node_192;
    last_cut_node = num_node_193;
    // 193,2,192
    faces.node_lists[ num_face ][ 0 ] = num_node_192;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_192 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) ;
    return;
}
case_5: {
    // n=3 00000100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_192 = std::min( num_node_2, num_node_0 );
    int max_node_192 = std::max( num_node_2, num_node_0 );
    int num_edge_192 = 64 * max_node_192 + min_node_192;
    int num_node_192;
    if ( edge_num_cut_procs[ num_edge_192 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_192 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_192;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_192 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_192 ] = num_cut_proc;
        edge_cuts[ num_edge_192 ] = num_node_192;
    } else
        num_node_192 = edge_cuts[ num_edge_192 ];
    prev_cut_nodes[ num_node_192 ] = num_node_193;
    last_cut_node = num_node_192;
    // 192,0,1,193
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_192;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_192 ) ;
    return;
}
case_6: {
    // n=3 00000101
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_128 ] = num_node_193;
    last_cut_node = num_node_128;
    // 128,1,193
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) ;
    return;
}
case_7: {
    // n=3 00000110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_192 = std::min( num_node_2, num_node_0 );
    int max_node_192 = std::max( num_node_2, num_node_0 );
    int num_edge_192 = 64 * max_node_192 + min_node_192;
    int num_node_192;
    if ( edge_num_cut_procs[ num_edge_192 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_192 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_192;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_192 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_192 ] = num_cut_proc;
        edge_cuts[ num_edge_192 ] = num_node_192;
    } else
        num_node_192 = edge_cuts[ num_edge_192 ];
    prev_cut_nodes[ num_node_192 ] = num_node_128;
    last_cut_node = num_node_192;
    // 192,0,128
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_192;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_192 ) ;
    return;
}
case_9: {
    // n=4 00000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_256 = std::min( num_node_3, num_node_0 );
    int max_node_256 = std::max( num_node_3, num_node_0 );
    int num_edge_256 = 64 * max_node_256 + min_node_256;
    int num_node_256;
    if ( edge_num_cut_procs[ num_edge_256 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_256 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_256;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_256 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_256 ] = num_cut_proc;
        edge_cuts[ num_edge_256 ] = num_node_256;
    } else
        num_node_256 = edge_cuts[ num_edge_256 ];
    prev_cut_nodes[ num_node_128 ] = num_node_256;
    last_cut_node = num_node_128;
    // 128,1,2,3,256
    faces.nb_nodes[ num_face ] = 5;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 4 ] = num_node_256;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_256 ) ;
    return;
}
case_10: {
    // n=4 00000010
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_193 ] = num_node_128;
    last_cut_node = num_node_193;
    // 0,128,193,2,3
    faces.nb_nodes[ num_face ] = 5;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_lists[ num_face ][ 4 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_11: {
    // n=4 00000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_256 = std::min( num_node_3, num_node_0 );
    int max_node_256 = std::max( num_node_3, num_node_0 );
    int num_edge_256 = 64 * max_node_256 + min_node_256;
    int num_node_256;
    if ( edge_num_cut_procs[ num_edge_256 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_256 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_256;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_256 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_256 ] = num_cut_proc;
        edge_cuts[ num_edge_256 ] = num_node_256;
    } else
        num_node_256 = edge_cuts[ num_edge_256 ];
    prev_cut_nodes[ num_node_193 ] = num_node_256;
    last_cut_node = num_node_193;
    // 193,2,3,256
    faces.node_lists[ num_face ][ 0 ] = num_node_256;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_256 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_12: {
    // n=4 00000100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_193;
    last_cut_node = num_node_258;
    // 0,1,193,258,3
    faces.nb_nodes[ num_face ] = 5;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_3;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_13: {
    // n=4 00000110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_128;
    last_cut_node = num_node_258;
    // 0,128,258,3
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_14: {
    // n=4 00000111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_256 = std::min( num_node_3, num_node_0 );
    int max_node_256 = std::max( num_node_3, num_node_0 );
    int num_edge_256 = 64 * max_node_256 + min_node_256;
    int num_node_256;
    if ( edge_num_cut_procs[ num_edge_256 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_256 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_256;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_256 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_256 ] = num_cut_proc;
        edge_cuts[ num_edge_256 ] = num_node_256;
    } else
        num_node_256 = edge_cuts[ num_edge_256 ];
    prev_cut_nodes[ num_node_258 ] = num_node_256;
    last_cut_node = num_node_258;
    // 258,3,256
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_3;
    faces.node_lists[ num_face ][ 2 ] = num_node_256;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_256 ) ;
    return;
}
case_15: {
    // n=4 00001000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_256 = std::min( num_node_3, num_node_0 );
    int max_node_256 = std::max( num_node_3, num_node_0 );
    int num_edge_256 = 64 * max_node_256 + min_node_256;
    int num_node_256;
    if ( edge_num_cut_procs[ num_edge_256 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_256 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_256;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_256 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_256 ] = num_cut_proc;
        edge_cuts[ num_edge_256 ] = num_node_256;
    } else
        num_node_256 = edge_cuts[ num_edge_256 ];
    prev_cut_nodes[ num_node_256 ] = num_node_258;
    last_cut_node = num_node_256;
    // 256,0,1,2,258
    faces.nb_nodes[ num_face ] = 5;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_256;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_256 ) ;
    return;
}
case_16: {
    // n=4 00001001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_128 ] = num_node_258;
    last_cut_node = num_node_128;
    // 128,1,2,258
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) ;
    return;
}
case_17: {
    // n=4 00001011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_193 ] = num_node_258;
    last_cut_node = num_node_193;
    // 193,2,258
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) ;
    return;
}
case_18: {
    // n=4 00001100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_256 = std::min( num_node_3, num_node_0 );
    int max_node_256 = std::max( num_node_3, num_node_0 );
    int num_edge_256 = 64 * max_node_256 + min_node_256;
    int num_node_256;
    if ( edge_num_cut_procs[ num_edge_256 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_256 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_256;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_256 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_256 ] = num_cut_proc;
        edge_cuts[ num_edge_256 ] = num_node_256;
    } else
        num_node_256 = edge_cuts[ num_edge_256 ];
    prev_cut_nodes[ num_node_256 ] = num_node_193;
    last_cut_node = num_node_256;
    // 256,0,1,193
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_256;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_256 ) ;
    return;
}
case_19: {
    // n=4 00001101
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_128 ] = num_node_193;
    last_cut_node = num_node_128;
    // 128,1,193
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) ;
    return;
}
case_20: {
    // n=4 00001110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_256 = std::min( num_node_3, num_node_0 );
    int max_node_256 = std::max( num_node_3, num_node_0 );
    int num_edge_256 = 64 * max_node_256 + min_node_256;
    int num_node_256;
    if ( edge_num_cut_procs[ num_edge_256 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_256 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_256;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_256 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_256 ] = num_cut_proc;
        edge_cuts[ num_edge_256 ] = num_node_256;
    } else
        num_node_256 = edge_cuts[ num_edge_256 ];
    prev_cut_nodes[ num_node_256 ] = num_node_128;
    last_cut_node = num_node_256;
    // 256,0,128
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_256;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_256 ) ;
    return;
}
case_21: {
    // n=5 00000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_320 = std::min( num_node_4, num_node_0 );
    int max_node_320 = std::max( num_node_4, num_node_0 );
    int num_edge_320 = 64 * max_node_320 + min_node_320;
    int num_node_320;
    if ( edge_num_cut_procs[ num_edge_320 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_320 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_320;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_320 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_320 ] = num_cut_proc;
        edge_cuts[ num_edge_320 ] = num_node_320;
    } else
        num_node_320 = edge_cuts[ num_edge_320 ];
    prev_cut_nodes[ num_node_128 ] = num_node_320;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,320
    faces.nb_nodes[ num_face ] = 6;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 5 ] = num_node_320;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_320 ) ;
    return;
}
case_22: {
    // n=5 00000010
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_193 ] = num_node_128;
    last_cut_node = num_node_193;
    // 0,128,193,2,3,4
    faces.nb_nodes[ num_face ] = 6;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_lists[ num_face ][ 5 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_23: {
    // n=5 00000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_320 = std::min( num_node_4, num_node_0 );
    int max_node_320 = std::max( num_node_4, num_node_0 );
    int num_edge_320 = 64 * max_node_320 + min_node_320;
    int num_node_320;
    if ( edge_num_cut_procs[ num_edge_320 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_320 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_320;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_320 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_320 ] = num_cut_proc;
        edge_cuts[ num_edge_320 ] = num_node_320;
    } else
        num_node_320 = edge_cuts[ num_edge_320 ];
    prev_cut_nodes[ num_node_193 ] = num_node_320;
    last_cut_node = num_node_193;
    // 193,2,3,4,320
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_320;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_320 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_24: {
    // n=5 00000100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_193;
    last_cut_node = num_node_258;
    // 0,1,193,258,3,4
    faces.nb_nodes[ num_face ] = 6;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_3;
    faces.node_lists[ num_face ][ 5 ] = num_node_4;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_25: {
    // n=5 00000110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_128;
    last_cut_node = num_node_258;
    // 0,128,258,3,4
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_26: {
    // n=5 00000111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_320 = std::min( num_node_4, num_node_0 );
    int max_node_320 = std::max( num_node_4, num_node_0 );
    int num_edge_320 = 64 * max_node_320 + min_node_320;
    int num_node_320;
    if ( edge_num_cut_procs[ num_edge_320 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_320 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_320;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_320 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_320 ] = num_cut_proc;
        edge_cuts[ num_edge_320 ] = num_node_320;
    } else
        num_node_320 = edge_cuts[ num_edge_320 ];
    prev_cut_nodes[ num_node_258 ] = num_node_320;
    last_cut_node = num_node_258;
    // 258,3,4,320
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_4;
    faces.node_lists[ num_face ][ 1 ] = num_node_320;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_320 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_27: {
    // n=5 00001000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_258;
    last_cut_node = num_node_323;
    // 0,1,2,258,323,4
    faces.nb_nodes[ num_face ] = 6;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_4;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_28: {
    // n=5 00001100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_193;
    last_cut_node = num_node_323;
    // 0,1,193,323,4
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_29: {
    // n=5 00001110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_128;
    last_cut_node = num_node_323;
    // 0,128,323,4
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_323;
    faces.node_lists[ num_face ][ 3 ] = num_node_4;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_30: {
    // n=5 00001111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_320 = std::min( num_node_4, num_node_0 );
    int max_node_320 = std::max( num_node_4, num_node_0 );
    int num_edge_320 = 64 * max_node_320 + min_node_320;
    int num_node_320;
    if ( edge_num_cut_procs[ num_edge_320 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_320 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_320;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_320 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_320 ] = num_cut_proc;
        edge_cuts[ num_edge_320 ] = num_node_320;
    } else
        num_node_320 = edge_cuts[ num_edge_320 ];
    prev_cut_nodes[ num_node_323 ] = num_node_320;
    last_cut_node = num_node_323;
    // 323,4,320
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_4;
    faces.node_lists[ num_face ][ 2 ] = num_node_320;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_320 ) ;
    return;
}
case_31: {
    // n=5 00010000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_320 = std::min( num_node_4, num_node_0 );
    int max_node_320 = std::max( num_node_4, num_node_0 );
    int num_edge_320 = 64 * max_node_320 + min_node_320;
    int num_node_320;
    if ( edge_num_cut_procs[ num_edge_320 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_320 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_320;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_320 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_320 ] = num_cut_proc;
        edge_cuts[ num_edge_320 ] = num_node_320;
    } else
        num_node_320 = edge_cuts[ num_edge_320 ];
    prev_cut_nodes[ num_node_320 ] = num_node_323;
    last_cut_node = num_node_320;
    // 320,0,1,2,3,323
    faces.nb_nodes[ num_face ] = 6;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_320;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_320 ) ;
    return;
}
case_32: {
    // n=5 00010001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_128 ] = num_node_323;
    last_cut_node = num_node_128;
    // 128,1,2,3,323
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) ;
    return;
}
case_33: {
    // n=5 00010011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_193 ] = num_node_323;
    last_cut_node = num_node_193;
    // 193,2,3,323
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_34: {
    // n=5 00010111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_258 ] = num_node_323;
    last_cut_node = num_node_258;
    // 258,3,323
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_3;
    faces.node_lists[ num_face ][ 2 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) ;
    return;
}
case_35: {
    // n=5 00011000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_320 = std::min( num_node_4, num_node_0 );
    int max_node_320 = std::max( num_node_4, num_node_0 );
    int num_edge_320 = 64 * max_node_320 + min_node_320;
    int num_node_320;
    if ( edge_num_cut_procs[ num_edge_320 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_320 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_320;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_320 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_320 ] = num_cut_proc;
        edge_cuts[ num_edge_320 ] = num_node_320;
    } else
        num_node_320 = edge_cuts[ num_edge_320 ];
    prev_cut_nodes[ num_node_320 ] = num_node_258;
    last_cut_node = num_node_320;
    // 320,0,1,2,258
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_320;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_320 ) ;
    return;
}
case_36: {
    // n=5 00011001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_128 ] = num_node_258;
    last_cut_node = num_node_128;
    // 128,1,2,258
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) ;
    return;
}
case_37: {
    // n=5 00011011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_193 ] = num_node_258;
    last_cut_node = num_node_193;
    // 193,2,258
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) ;
    return;
}
case_38: {
    // n=5 00011100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_320 = std::min( num_node_4, num_node_0 );
    int max_node_320 = std::max( num_node_4, num_node_0 );
    int num_edge_320 = 64 * max_node_320 + min_node_320;
    int num_node_320;
    if ( edge_num_cut_procs[ num_edge_320 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_320 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_320;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_320 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_320 ] = num_cut_proc;
        edge_cuts[ num_edge_320 ] = num_node_320;
    } else
        num_node_320 = edge_cuts[ num_edge_320 ];
    prev_cut_nodes[ num_node_320 ] = num_node_193;
    last_cut_node = num_node_320;
    // 320,0,1,193
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_320;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_320 ) ;
    return;
}
case_39: {
    // n=5 00011101
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_128 ] = num_node_193;
    last_cut_node = num_node_128;
    // 128,1,193
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) ;
    return;
}
case_40: {
    // n=5 00011110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_320 = std::min( num_node_4, num_node_0 );
    int max_node_320 = std::max( num_node_4, num_node_0 );
    int num_edge_320 = 64 * max_node_320 + min_node_320;
    int num_node_320;
    if ( edge_num_cut_procs[ num_edge_320 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_320 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_320;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_320 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_320 ] = num_cut_proc;
        edge_cuts[ num_edge_320 ] = num_node_320;
    } else
        num_node_320 = edge_cuts[ num_edge_320 ];
    prev_cut_nodes[ num_node_320 ] = num_node_128;
    last_cut_node = num_node_320;
    // 320,0,128
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_320;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_320 ) ;
    return;
}
case_41: {
    // n=6 00000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_128 ] = num_node_384;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,5,384
    faces.nb_nodes[ num_face ] = 7;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 6 ] = num_node_384;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) ;
    return;
}
case_42: {
    // n=6 00000010
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_193 ] = num_node_128;
    last_cut_node = num_node_193;
    // 0,128,193,2,3,4,5
    faces.nb_nodes[ num_face ] = 7;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_lists[ num_face ][ 6 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_43: {
    // n=6 00000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_193 ] = num_node_384;
    last_cut_node = num_node_193;
    // 193,2,3,4,5,384
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_384;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_384 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_44: {
    // n=6 00000100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_193;
    last_cut_node = num_node_258;
    // 0,1,193,258,3,4,5
    faces.nb_nodes[ num_face ] = 7;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_1;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_lists[ num_face ][ 6 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_45: {
    // n=6 00000110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_128;
    last_cut_node = num_node_258;
    // 0,128,258,3,4,5
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_46: {
    // n=6 00000111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_258 ] = num_node_384;
    last_cut_node = num_node_258;
    // 258,3,4,5,384
    faces.nb_nodes[ num_face ] = 5;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_5;
    faces.node_lists[ num_face ][ 1 ] = num_node_384;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_47: {
    // n=6 00001000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_258;
    last_cut_node = num_node_323;
    // 0,1,2,258,323,4,5
    faces.nb_nodes[ num_face ] = 7;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_4;
    faces.node_lists[ num_face ][ 6 ] = num_node_5;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_48: {
    // n=6 00001100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_193;
    last_cut_node = num_node_323;
    // 0,1,193,323,4,5
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_49: {
    // n=6 00001110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_128;
    last_cut_node = num_node_323;
    // 0,128,323,4,5
    faces.nb_nodes[ num_face ] = 5;
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_323;
    faces.node_lists[ num_face ][ 3 ] = num_node_4;
    faces.node_lists[ num_face ][ 4 ] = num_node_5;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_50: {
    // n=6 00001111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_323 ] = num_node_384;
    last_cut_node = num_node_323;
    // 323,4,5,384
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_4;
    faces.node_lists[ num_face ][ 2 ] = num_node_5;
    faces.node_lists[ num_face ][ 3 ] = num_node_384;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) ;
    return;
}
case_51: {
    // n=6 00010000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_323;
    last_cut_node = num_node_388;
    // 0,1,2,3,323,388,5
    faces.nb_nodes[ num_face ] = 7;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_5;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_52: {
    // n=6 00011000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_258;
    last_cut_node = num_node_388;
    // 0,1,2,258,388,5
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_53: {
    // n=6 00011100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_193;
    last_cut_node = num_node_388;
    // 0,1,193,388,5
    faces.nb_nodes[ num_face ] = 5;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_388;
    faces.node_lists[ num_face ][ 4 ] = num_node_5;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_54: {
    // n=6 00011110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_128;
    last_cut_node = num_node_388;
    // 0,128,388,5
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_388;
    faces.node_lists[ num_face ][ 3 ] = num_node_5;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_55: {
    // n=6 00011111
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_388 ] = num_node_384;
    last_cut_node = num_node_388;
    // 388,5,384
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_5;
    faces.node_lists[ num_face ][ 2 ] = num_node_384;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) ;
    return;
}
case_56: {
    // n=6 00100000
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_384 ] = num_node_388;
    last_cut_node = num_node_384;
    // 384,0,1,2,3,4,388
    faces.nb_nodes[ num_face ] = 7;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_384;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) ;
    return;
}
case_57: {
    // n=6 00100001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_128 ] = num_node_388;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,388
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) ;
    return;
}
case_58: {
    // n=6 00100011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_193 ] = num_node_388;
    last_cut_node = num_node_193;
    // 193,2,3,4,388
    faces.nb_nodes[ num_face ] = 5;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_59: {
    // n=6 00100111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_258 ] = num_node_388;
    last_cut_node = num_node_258;
    // 258,3,4,388
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_4;
    faces.node_lists[ num_face ][ 1 ] = num_node_388;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_60: {
    // n=6 00101111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_323 ] = num_node_388;
    last_cut_node = num_node_323;
    // 323,4,388
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_4;
    faces.node_lists[ num_face ][ 2 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) ;
    return;
}
case_61: {
    // n=6 00110000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_384 ] = num_node_323;
    last_cut_node = num_node_384;
    // 384,0,1,2,3,323
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_384;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) ;
    return;
}
case_62: {
    // n=6 00110001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_128 ] = num_node_323;
    last_cut_node = num_node_128;
    // 128,1,2,3,323
    faces.nb_nodes[ num_face ] = 5;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) ;
    return;
}
case_63: {
    // n=6 00110011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_193 ] = num_node_323;
    last_cut_node = num_node_193;
    // 193,2,3,323
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_64: {
    // n=6 00110111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_258 ] = num_node_323;
    last_cut_node = num_node_258;
    // 258,3,323
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_3;
    faces.node_lists[ num_face ][ 2 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) ;
    return;
}
case_65: {
    // n=6 00111000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_384 ] = num_node_258;
    last_cut_node = num_node_384;
    // 384,0,1,2,258
    faces.nb_nodes[ num_face ] = 5;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_384;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) ;
    return;
}
case_66: {
    // n=6 00111001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_128 ] = num_node_258;
    last_cut_node = num_node_128;
    // 128,1,2,258
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) ;
    return;
}
case_67: {
    // n=6 00111011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_193 ] = num_node_258;
    last_cut_node = num_node_193;
    // 193,2,258
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) ;
    return;
}
case_68: {
    // n=6 00111100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_384 ] = num_node_193;
    last_cut_node = num_node_384;
    // 384,0,1,193
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_384;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) ;
    return;
}
case_69: {
    // n=6 00111101
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_128 ] = num_node_193;
    last_cut_node = num_node_128;
    // 128,1,193
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) ;
    return;
}
case_70: {
    // n=6 00111110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_384 = std::min( num_node_5, num_node_0 );
    int max_node_384 = std::max( num_node_5, num_node_0 );
    int num_edge_384 = 64 * max_node_384 + min_node_384;
    int num_node_384;
    if ( edge_num_cut_procs[ num_edge_384 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_384 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_384;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_384 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_384 ] = num_cut_proc;
        edge_cuts[ num_edge_384 ] = num_node_384;
    } else
        num_node_384 = edge_cuts[ num_edge_384 ];
    prev_cut_nodes[ num_node_384 ] = num_node_128;
    last_cut_node = num_node_384;
    // 384,0,128
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_384;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_384 ) ;
    return;
}
case_71: {
    // n=7 00000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_128 ] = num_node_448;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,5,6,448
    faces.nb_nodes[ num_face ] = 8;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 7 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_72: {
    // n=7 00000010
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_193 ] = num_node_128;
    last_cut_node = num_node_193;
    // 0,128,193,2,3,4,5,6
    faces.nb_nodes[ num_face ] = 8;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_lists[ num_face ][ 7 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_73: {
    // n=7 00000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_193 ] = num_node_448;
    last_cut_node = num_node_193;
    // 193,2,3,4,5,6,448
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_448;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_448 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_74: {
    // n=7 00000100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_193;
    last_cut_node = num_node_258;
    // 0,1,193,258,3,4,5,6
    faces.nb_nodes[ num_face ] = 8;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_1;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_lists[ num_face ][ 7 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_75: {
    // n=7 00000110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_128;
    last_cut_node = num_node_258;
    // 0,128,258,3,4,5,6
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_76: {
    // n=7 00000111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_258 ] = num_node_448;
    last_cut_node = num_node_258;
    // 258,3,4,5,6,448
    faces.nb_nodes[ num_face ] = 6;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_6;
    faces.node_lists[ num_face ][ 1 ] = num_node_448;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_77: {
    // n=7 00001000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_258;
    last_cut_node = num_node_323;
    // 0,1,2,258,323,4,5,6
    faces.nb_nodes[ num_face ] = 8;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_4;
    faces.node_lists[ num_face ][ 6 ] = num_node_5;
    faces.node_lists[ num_face ][ 7 ] = num_node_6;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_78: {
    // n=7 00001100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_193;
    last_cut_node = num_node_323;
    // 0,1,193,323,4,5,6
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_79: {
    // n=7 00001110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_128;
    last_cut_node = num_node_323;
    // 0,128,323,4,5,6
    faces.nb_nodes[ num_face ] = 6;
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_6;
    faces.node_lists[ num_face ][ 1 ] = num_node_0;
    faces.node_lists[ num_face ][ 2 ] = num_node_128;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_80: {
    // n=7 00001111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_323 ] = num_node_448;
    last_cut_node = num_node_323;
    // 323,4,5,6,448
    faces.nb_nodes[ num_face ] = 5;
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_5;
    faces.node_lists[ num_face ][ 1 ] = num_node_6;
    faces.node_lists[ num_face ][ 2 ] = num_node_448;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_81: {
    // n=7 00010000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_323;
    last_cut_node = num_node_388;
    // 0,1,2,3,323,388,5,6
    faces.nb_nodes[ num_face ] = 8;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_5;
    faces.node_lists[ num_face ][ 7 ] = num_node_6;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_82: {
    // n=7 00011000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_258;
    last_cut_node = num_node_388;
    // 0,1,2,258,388,5,6
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_83: {
    // n=7 00011100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_193;
    last_cut_node = num_node_388;
    // 0,1,193,388,5,6
    faces.nb_nodes[ num_face ] = 6;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_388;
    faces.node_lists[ num_face ][ 4 ] = num_node_5;
    faces.node_lists[ num_face ][ 5 ] = num_node_6;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_84: {
    // n=7 00011110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_128;
    last_cut_node = num_node_388;
    // 0,128,388,5,6
    faces.nb_nodes[ num_face ] = 5;
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_388;
    faces.node_lists[ num_face ][ 3 ] = num_node_5;
    faces.node_lists[ num_face ][ 4 ] = num_node_6;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_85: {
    // n=7 00011111
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_388 ] = num_node_448;
    last_cut_node = num_node_388;
    // 388,5,6,448
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_5;
    faces.node_lists[ num_face ][ 2 ] = num_node_6;
    faces.node_lists[ num_face ][ 3 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_86: {
    // n=7 00100000
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_388;
    last_cut_node = num_node_453;
    // 0,1,2,3,4,388,453,6
    faces.nb_nodes[ num_face ] = 8;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_453;
    faces.node_lists[ num_face ][ 7 ] = num_node_6;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_87: {
    // n=7 00110000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_323;
    last_cut_node = num_node_453;
    // 0,1,2,3,323,453,6
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_453;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_88: {
    // n=7 00111000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_258;
    last_cut_node = num_node_453;
    // 0,1,2,258,453,6
    faces.nb_nodes[ num_face ] = 6;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_453;
    faces.node_lists[ num_face ][ 5 ] = num_node_6;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_89: {
    // n=7 00111100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_193;
    last_cut_node = num_node_453;
    // 0,1,193,453,6
    faces.nb_nodes[ num_face ] = 5;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_453;
    faces.node_lists[ num_face ][ 4 ] = num_node_6;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_90: {
    // n=7 00111110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_128;
    last_cut_node = num_node_453;
    // 0,128,453,6
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_453;
    faces.node_lists[ num_face ][ 3 ] = num_node_6;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_91: {
    // n=7 00111111
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_453 ] = num_node_448;
    last_cut_node = num_node_453;
    // 453,6,448
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_453;
    faces.node_lists[ num_face ][ 1 ] = num_node_6;
    faces.node_lists[ num_face ][ 2 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_92: {
    // n=7 01000000
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_448 ] = num_node_453;
    last_cut_node = num_node_448;
    // 448,0,1,2,3,4,5,453
    faces.nb_nodes[ num_face ] = 8;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 6 ] = num_node_453;
    faces.node_lists[ num_face ][ 7 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_93: {
    // n=7 01000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_128 ] = num_node_453;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,5,453
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 6 ] = num_node_453;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) ;
    return;
}
case_94: {
    // n=7 01000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_193 ] = num_node_453;
    last_cut_node = num_node_193;
    // 193,2,3,4,5,453
    faces.nb_nodes[ num_face ] = 6;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_453;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_95: {
    // n=7 01000111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_258 ] = num_node_453;
    last_cut_node = num_node_258;
    // 258,3,4,5,453
    faces.nb_nodes[ num_face ] = 5;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_5;
    faces.node_lists[ num_face ][ 1 ] = num_node_453;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_96: {
    // n=7 01001111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_323 ] = num_node_453;
    last_cut_node = num_node_323;
    // 323,4,5,453
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_4;
    faces.node_lists[ num_face ][ 2 ] = num_node_5;
    faces.node_lists[ num_face ][ 3 ] = num_node_453;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) ;
    return;
}
case_97: {
    // n=7 01011111
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_388 ] = num_node_453;
    last_cut_node = num_node_388;
    // 388,5,453
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_5;
    faces.node_lists[ num_face ][ 2 ] = num_node_453;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) ;
    return;
}
case_98: {
    // n=7 01100000
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_448 ] = num_node_388;
    last_cut_node = num_node_448;
    // 448,0,1,2,3,4,388
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_99: {
    // n=7 01100001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_128 ] = num_node_388;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,388
    faces.nb_nodes[ num_face ] = 6;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) ;
    return;
}
case_100: {
    // n=7 01100011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_193 ] = num_node_388;
    last_cut_node = num_node_193;
    // 193,2,3,4,388
    faces.nb_nodes[ num_face ] = 5;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_101: {
    // n=7 01100111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_258 ] = num_node_388;
    last_cut_node = num_node_258;
    // 258,3,4,388
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_4;
    faces.node_lists[ num_face ][ 1 ] = num_node_388;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_102: {
    // n=7 01101111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_323 ] = num_node_388;
    last_cut_node = num_node_323;
    // 323,4,388
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_4;
    faces.node_lists[ num_face ][ 2 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) ;
    return;
}
case_103: {
    // n=7 01110000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_448 ] = num_node_323;
    last_cut_node = num_node_448;
    // 448,0,1,2,3,323
    faces.nb_nodes[ num_face ] = 6;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_104: {
    // n=7 01110001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_128 ] = num_node_323;
    last_cut_node = num_node_128;
    // 128,1,2,3,323
    faces.nb_nodes[ num_face ] = 5;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) ;
    return;
}
case_105: {
    // n=7 01110011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_193 ] = num_node_323;
    last_cut_node = num_node_193;
    // 193,2,3,323
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_106: {
    // n=7 01110111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_258 ] = num_node_323;
    last_cut_node = num_node_258;
    // 258,3,323
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_3;
    faces.node_lists[ num_face ][ 2 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) ;
    return;
}
case_107: {
    // n=7 01111000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_448 ] = num_node_258;
    last_cut_node = num_node_448;
    // 448,0,1,2,258
    faces.nb_nodes[ num_face ] = 5;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_108: {
    // n=7 01111001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_128 ] = num_node_258;
    last_cut_node = num_node_128;
    // 128,1,2,258
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) ;
    return;
}
case_109: {
    // n=7 01111011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_193 ] = num_node_258;
    last_cut_node = num_node_193;
    // 193,2,258
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) ;
    return;
}
case_110: {
    // n=7 01111100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_448 ] = num_node_193;
    last_cut_node = num_node_448;
    // 448,0,1,193
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_111: {
    // n=7 01111101
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_128 ] = num_node_193;
    last_cut_node = num_node_128;
    // 128,1,193
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) ;
    return;
}
case_112: {
    // n=7 01111110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_448 = std::min( num_node_6, num_node_0 );
    int max_node_448 = std::max( num_node_6, num_node_0 );
    int num_edge_448 = 64 * max_node_448 + min_node_448;
    int num_node_448;
    if ( edge_num_cut_procs[ num_edge_448 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_448 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_448;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_448 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_448 ] = num_cut_proc;
        edge_cuts[ num_edge_448 ] = num_node_448;
    } else
        num_node_448 = edge_cuts[ num_edge_448 ];
    prev_cut_nodes[ num_node_448 ] = num_node_128;
    last_cut_node = num_node_448;
    // 448,0,128
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_448;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_448 ) ;
    return;
}
case_113: {
    // n=8 00000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_128 ] = num_node_512;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,5,6,7,512
    faces.nb_nodes[ num_face ] = 9;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 8 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_114: {
    // n=8 00000010
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_193 ] = num_node_128;
    last_cut_node = num_node_193;
    // 0,128,193,2,3,4,5,6,7
    faces.nb_nodes[ num_face ] = 9;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_lists[ num_face ][ 8 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_115: {
    // n=8 00000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_193 ] = num_node_512;
    last_cut_node = num_node_193;
    // 193,2,3,4,5,6,7,512
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_512;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_512 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_116: {
    // n=8 00000100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_193;
    last_cut_node = num_node_258;
    // 0,1,193,258,3,4,5,6,7
    faces.nb_nodes[ num_face ] = 9;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_1;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_lists[ num_face ][ 8 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_117: {
    // n=8 00000110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_258 ] = num_node_128;
    last_cut_node = num_node_258;
    // 0,128,258,3,4,5,6,7
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_118: {
    // n=8 00000111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_258 ] = num_node_512;
    last_cut_node = num_node_258;
    // 258,3,4,5,6,7,512
    faces.nb_nodes[ num_face ] = 7;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_7;
    faces.node_lists[ num_face ][ 1 ] = num_node_512;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_119: {
    // n=8 00001000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_258;
    last_cut_node = num_node_323;
    // 0,1,2,258,323,4,5,6,7
    faces.nb_nodes[ num_face ] = 9;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_1;
    faces.node_lists[ num_face ][ 1 ] = num_node_2;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_lists[ num_face ][ 8 ] = num_node_0;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) ;
    return;
}
case_120: {
    // n=8 00001100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_193;
    last_cut_node = num_node_323;
    // 0,1,193,323,4,5,6,7
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_121: {
    // n=8 00001110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_323 ] = num_node_128;
    last_cut_node = num_node_323;
    // 0,128,323,4,5,6,7
    faces.nb_nodes[ num_face ] = 7;
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_7;
    faces.node_lists[ num_face ][ 1 ] = num_node_0;
    faces.node_lists[ num_face ][ 2 ] = num_node_128;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_122: {
    // n=8 00001111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_323 ] = num_node_512;
    last_cut_node = num_node_323;
    // 323,4,5,6,7,512
    faces.nb_nodes[ num_face ] = 6;
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_6;
    faces.node_lists[ num_face ][ 1 ] = num_node_7;
    faces.node_lists[ num_face ][ 2 ] = num_node_512;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_123: {
    // n=8 00010000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_323;
    last_cut_node = num_node_388;
    // 0,1,2,3,323,388,5,6,7
    faces.nb_nodes[ num_face ] = 9;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_5;
    faces.node_lists[ num_face ][ 7 ] = num_node_6;
    faces.node_lists[ num_face ][ 8 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_124: {
    // n=8 00011000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_258;
    last_cut_node = num_node_388;
    // 0,1,2,258,388,5,6,7
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_125: {
    // n=8 00011100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_193;
    last_cut_node = num_node_388;
    // 0,1,193,388,5,6,7
    faces.nb_nodes[ num_face ] = 7;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_388;
    faces.node_lists[ num_face ][ 4 ] = num_node_5;
    faces.node_lists[ num_face ][ 5 ] = num_node_6;
    faces.node_lists[ num_face ][ 6 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_126: {
    // n=8 00011110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_388 ] = num_node_128;
    last_cut_node = num_node_388;
    // 0,128,388,5,6,7
    faces.nb_nodes[ num_face ] = 6;
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_388;
    faces.node_lists[ num_face ][ 3 ] = num_node_5;
    faces.node_lists[ num_face ][ 4 ] = num_node_6;
    faces.node_lists[ num_face ][ 5 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_127: {
    // n=8 00011111
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_388 ] = num_node_512;
    last_cut_node = num_node_388;
    // 388,5,6,7,512
    faces.nb_nodes[ num_face ] = 5;
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_5;
    faces.node_lists[ num_face ][ 2 ] = num_node_6;
    faces.node_lists[ num_face ][ 3 ] = num_node_7;
    faces.node_lists[ num_face ][ 4 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_128: {
    // n=8 00100000
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_388;
    last_cut_node = num_node_453;
    // 0,1,2,3,4,388,453,6,7
    faces.nb_nodes[ num_face ] = 9;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_453;
    faces.node_lists[ num_face ][ 7 ] = num_node_6;
    faces.node_lists[ num_face ][ 8 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_129: {
    // n=8 00110000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_323;
    last_cut_node = num_node_453;
    // 0,1,2,3,323,453,6,7
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_453;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_130: {
    // n=8 00111000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_258;
    last_cut_node = num_node_453;
    // 0,1,2,258,453,6,7
    faces.nb_nodes[ num_face ] = 7;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_453;
    faces.node_lists[ num_face ][ 5 ] = num_node_6;
    faces.node_lists[ num_face ][ 6 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_131: {
    // n=8 00111100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_193;
    last_cut_node = num_node_453;
    // 0,1,193,453,6,7
    faces.nb_nodes[ num_face ] = 6;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_453;
    faces.node_lists[ num_face ][ 4 ] = num_node_6;
    faces.node_lists[ num_face ][ 5 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_132: {
    // n=8 00111110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_453 ] = num_node_128;
    last_cut_node = num_node_453;
    // 0,128,453,6,7
    faces.nb_nodes[ num_face ] = 5;
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_453;
    faces.node_lists[ num_face ][ 3 ] = num_node_6;
    faces.node_lists[ num_face ][ 4 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_133: {
    // n=8 00111111
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_453 ] = num_node_512;
    last_cut_node = num_node_453;
    // 453,6,7,512
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_453;
    faces.node_lists[ num_face ][ 1 ] = num_node_6;
    faces.node_lists[ num_face ][ 2 ] = num_node_7;
    faces.node_lists[ num_face ][ 3 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_134: {
    // n=8 01000000
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_518 ] = num_node_453;
    last_cut_node = num_node_518;
    // 0,1,2,3,4,5,453,518,7
    faces.nb_nodes[ num_face ] = 9;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 6 ] = num_node_453;
    faces.node_lists[ num_face ][ 7 ] = num_node_518;
    faces.node_lists[ num_face ][ 8 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_135: {
    // n=8 01100000
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_518 ] = num_node_388;
    last_cut_node = num_node_518;
    // 0,1,2,3,4,388,518,7
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_518;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_136: {
    // n=8 01110000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_518 ] = num_node_323;
    last_cut_node = num_node_518;
    // 0,1,2,3,323,518,7
    faces.nb_nodes[ num_face ] = 7;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_518;
    faces.node_lists[ num_face ][ 6 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_137: {
    // n=8 01111000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_518 ] = num_node_258;
    last_cut_node = num_node_518;
    // 0,1,2,258,518,7
    faces.nb_nodes[ num_face ] = 6;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_518;
    faces.node_lists[ num_face ][ 5 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_138: {
    // n=8 01111100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_518 ] = num_node_193;
    last_cut_node = num_node_518;
    // 0,1,193,518,7
    faces.nb_nodes[ num_face ] = 5;
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_518;
    faces.node_lists[ num_face ][ 4 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_139: {
    // n=8 01111110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_518 ] = num_node_128;
    last_cut_node = num_node_518;
    // 0,128,518,7
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_518;
    faces.node_lists[ num_face ][ 3 ] = num_node_7;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) ;
    return;
}
case_140: {
    // n=8 01111111
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_518 ] = num_node_512;
    last_cut_node = num_node_518;
    // 518,7,512
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_518;
    faces.node_lists[ num_face ][ 1 ] = num_node_7;
    faces.node_lists[ num_face ][ 2 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_7 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_141: {
    // n=8 10000000
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_512 ] = num_node_518;
    last_cut_node = num_node_512;
    // 512,0,1,2,3,4,5,6,518
    faces.nb_nodes[ num_face ] = 9;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 7 ] = num_node_518;
    faces.node_lists[ num_face ][ 8 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_142: {
    // n=8 10000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_128 ] = num_node_518;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,5,6,518
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 7 ] = num_node_518;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) ;
    return;
}
case_143: {
    // n=8 10000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_193 ] = num_node_518;
    last_cut_node = num_node_193;
    // 193,2,3,4,5,6,518
    faces.nb_nodes[ num_face ] = 7;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_518;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) ;
    return;
}
case_144: {
    // n=8 10000111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_258 ] = num_node_518;
    last_cut_node = num_node_258;
    // 258,3,4,5,6,518
    faces.nb_nodes[ num_face ] = 6;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_6;
    faces.node_lists[ num_face ][ 1 ] = num_node_518;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_145: {
    // n=8 10001111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_323 ] = num_node_518;
    last_cut_node = num_node_323;
    // 323,4,5,6,518
    faces.nb_nodes[ num_face ] = 5;
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_5;
    faces.node_lists[ num_face ][ 1 ] = num_node_6;
    faces.node_lists[ num_face ][ 2 ] = num_node_518;
    faces.node_lists[ num_face ][ 3 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_146: {
    // n=8 10011111
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_388 ] = num_node_518;
    last_cut_node = num_node_388;
    // 388,5,6,518
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_5;
    faces.node_lists[ num_face ][ 2 ] = num_node_6;
    faces.node_lists[ num_face ][ 3 ] = num_node_518;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) ;
    return;
}
case_147: {
    // n=8 10111111
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_518 = std::min( num_node_6, num_node_7 );
    int max_node_518 = std::max( num_node_6, num_node_7 );
    int num_edge_518 = 64 * max_node_518 + min_node_518;
    int num_node_518;
    if ( edge_num_cut_procs[ num_edge_518 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_518 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_518;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_518 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_6 );
        const Node &n1 = nodes.local_at( num_node_7 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_518 ] = num_cut_proc;
        edge_cuts[ num_edge_518 ] = num_node_518;
    } else
        num_node_518 = edge_cuts[ num_edge_518 ];
    prev_cut_nodes[ num_node_453 ] = num_node_518;
    last_cut_node = num_node_453;
    // 453,6,518
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_453;
    faces.node_lists[ num_face ][ 1 ] = num_node_6;
    faces.node_lists[ num_face ][ 2 ] = num_node_518;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_6 ) |
        ( std::uint64_t( 1 ) << num_node_518 ) ;
    return;
}
case_148: {
    // n=8 11000000
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_512 ] = num_node_453;
    last_cut_node = num_node_512;
    // 512,0,1,2,3,4,5,453
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 6 ] = num_node_453;
    faces.node_lists[ num_face ][ 7 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_149: {
    // n=8 11000001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_128 ] = num_node_453;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,5,453
    faces.nb_nodes[ num_face ] = 7;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 6 ] = num_node_453;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) ;
    return;
}
case_150: {
    // n=8 11000011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_193 ] = num_node_453;
    last_cut_node = num_node_193;
    // 193,2,3,4,5,453
    faces.nb_nodes[ num_face ] = 6;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_453;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) ;
    return;
}
case_151: {
    // n=8 11000111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_258 ] = num_node_453;
    last_cut_node = num_node_258;
    // 258,3,4,5,453
    faces.nb_nodes[ num_face ] = 5;
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_5;
    faces.node_lists[ num_face ][ 1 ] = num_node_453;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_152: {
    // n=8 11001111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_323 ] = num_node_453;
    last_cut_node = num_node_323;
    // 323,4,5,453
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_4;
    faces.node_lists[ num_face ][ 2 ] = num_node_5;
    faces.node_lists[ num_face ][ 3 ] = num_node_453;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) ;
    return;
}
case_153: {
    // n=8 11011111
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_6 = faces.node_lists[ num_face ][ 6 ];
    int min_node_453 = std::min( num_node_5, num_node_6 );
    int max_node_453 = std::max( num_node_5, num_node_6 );
    int num_edge_453 = 64 * max_node_453 + min_node_453;
    int num_node_453;
    if ( edge_num_cut_procs[ num_edge_453 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_453 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_453;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_453 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_5 );
        const Node &n1 = nodes.local_at( num_node_6 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_453 ] = num_cut_proc;
        edge_cuts[ num_edge_453 ] = num_node_453;
    } else
        num_node_453 = edge_cuts[ num_edge_453 ];
    prev_cut_nodes[ num_node_388 ] = num_node_453;
    last_cut_node = num_node_388;
    // 388,5,453
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_5;
    faces.node_lists[ num_face ][ 2 ] = num_node_453;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_5 ) |
        ( std::uint64_t( 1 ) << num_node_453 ) ;
    return;
}
case_154: {
    // n=8 11100000
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_512 ] = num_node_388;
    last_cut_node = num_node_512;
    // 512,0,1,2,3,4,388
    faces.nb_nodes[ num_face ] = 7;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_lists[ num_face ][ 6 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_155: {
    // n=8 11100001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_128 ] = num_node_388;
    last_cut_node = num_node_128;
    // 128,1,2,3,4,388
    faces.nb_nodes[ num_face ] = 6;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 5 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) ;
    return;
}
case_156: {
    // n=8 11100011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_193 ] = num_node_388;
    last_cut_node = num_node_193;
    // 193,2,3,4,388
    faces.nb_nodes[ num_face ] = 5;
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_388;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) ;
    return;
}
case_157: {
    // n=8 11100111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_258 ] = num_node_388;
    last_cut_node = num_node_258;
    // 258,3,4,388
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_4;
    faces.node_lists[ num_face ][ 1 ] = num_node_388;
    faces.node_lists[ num_face ][ 2 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_158: {
    // n=8 11101111
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_5 = faces.node_lists[ num_face ][ 5 ];
    int min_node_388 = std::min( num_node_4, num_node_5 );
    int max_node_388 = std::max( num_node_4, num_node_5 );
    int num_edge_388 = 64 * max_node_388 + min_node_388;
    int num_node_388;
    if ( edge_num_cut_procs[ num_edge_388 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_388 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_388;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_388 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_4 );
        const Node &n1 = nodes.local_at( num_node_5 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_388 ] = num_cut_proc;
        edge_cuts[ num_edge_388 ] = num_node_388;
    } else
        num_node_388 = edge_cuts[ num_edge_388 ];
    prev_cut_nodes[ num_node_323 ] = num_node_388;
    last_cut_node = num_node_323;
    // 323,4,388
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_4;
    faces.node_lists[ num_face ][ 2 ] = num_node_388;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_4 ) |
        ( std::uint64_t( 1 ) << num_node_388 ) ;
    return;
}
case_159: {
    // n=8 11110000
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_512 ] = num_node_323;
    last_cut_node = num_node_512;
    // 512,0,1,2,3,323
    faces.nb_nodes[ num_face ] = 6;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_lists[ num_face ][ 5 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_160: {
    // n=8 11110001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_128 ] = num_node_323;
    last_cut_node = num_node_128;
    // 128,1,2,3,323
    faces.nb_nodes[ num_face ] = 5;
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 4 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) ;
    return;
}
case_161: {
    // n=8 11110011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_193 ] = num_node_323;
    last_cut_node = num_node_193;
    // 193,2,3,323
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_323;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_323 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) ;
    return;
}
case_162: {
    // n=8 11110111
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_4 = faces.node_lists[ num_face ][ 4 ];
    int min_node_323 = std::min( num_node_3, num_node_4 );
    int max_node_323 = std::max( num_node_3, num_node_4 );
    int num_edge_323 = 64 * max_node_323 + min_node_323;
    int num_node_323;
    if ( edge_num_cut_procs[ num_edge_323 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_323 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_323;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_323 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_3 );
        const Node &n1 = nodes.local_at( num_node_4 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_323 ] = num_cut_proc;
        edge_cuts[ num_edge_323 ] = num_node_323;
    } else
        num_node_323 = edge_cuts[ num_edge_323 ];
    prev_cut_nodes[ num_node_258 ] = num_node_323;
    last_cut_node = num_node_258;
    // 258,3,323
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_3;
    faces.node_lists[ num_face ][ 2 ] = num_node_323;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_3 ) |
        ( std::uint64_t( 1 ) << num_node_323 ) ;
    return;
}
case_163: {
    // n=8 11111000
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_512 ] = num_node_258;
    last_cut_node = num_node_512;
    // 512,0,1,2,258
    faces.nb_nodes[ num_face ] = 5;
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_lists[ num_face ][ 4 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_164: {
    // n=8 11111001
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_128 ] = num_node_258;
    last_cut_node = num_node_128;
    // 128,1,2,258
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 3 ] = num_node_258;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) |
        ( std::uint64_t( 1 ) << num_node_258 ) ;
    return;
}
case_165: {
    // n=8 11111011
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_3 = faces.node_lists[ num_face ][ 3 ];
    int min_node_258 = std::min( num_node_2, num_node_3 );
    int max_node_258 = std::max( num_node_2, num_node_3 );
    int num_edge_258 = 64 * max_node_258 + min_node_258;
    int num_node_258;
    if ( edge_num_cut_procs[ num_edge_258 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_258 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_258;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_258 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_2 );
        const Node &n1 = nodes.local_at( num_node_3 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_258 ] = num_cut_proc;
        edge_cuts[ num_edge_258 ] = num_node_258;
    } else
        num_node_258 = edge_cuts[ num_edge_258 ];
    prev_cut_nodes[ num_node_193 ] = num_node_258;
    last_cut_node = num_node_193;
    // 193,2,258
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_258;
    faces.node_lists[ num_face ][ 1 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_258 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_2 ) ;
    return;
}
case_166: {
    // n=8 11111100
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_512 ] = num_node_193;
    last_cut_node = num_node_512;
    // 512,0,1,193
    faces.nb_nodes[ num_face ] = 4;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_lists[ num_face ][ 3 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_167: {
    // n=8 11111101
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_2 = faces.node_lists[ num_face ][ 2 ];
    int min_node_193 = std::min( num_node_1, num_node_2 );
    int max_node_193 = std::max( num_node_1, num_node_2 );
    int num_edge_193 = 64 * max_node_193 + min_node_193;
    int num_node_193;
    if ( edge_num_cut_procs[ num_edge_193 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_193 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_193;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_193 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_1 );
        const Node &n1 = nodes.local_at( num_node_2 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_193 ] = num_cut_proc;
        edge_cuts[ num_edge_193 ] = num_node_193;
    } else
        num_node_193 = edge_cuts[ num_edge_193 ];
    prev_cut_nodes[ num_node_128 ] = num_node_193;
    last_cut_node = num_node_128;
    // 128,1,193
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 0 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_193;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_1 ) |
        ( std::uint64_t( 1 ) << num_node_193 ) ;
    return;
}
case_168: {
    // n=8 11111110
    int num_node_0 = faces.node_lists[ num_face ][ 0 ];
    int num_node_1 = faces.node_lists[ num_face ][ 1 ];
    int min_node_128 = std::min( num_node_0, num_node_1 );
    int max_node_128 = std::max( num_node_0, num_node_1 );
    int num_edge_128 = 64 * max_node_128 + min_node_128;
    int num_node_128;
    if ( edge_num_cut_procs[ num_edge_128 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_128 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_128;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_128 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_0 );
        const Node &n1 = nodes.local_at( num_node_1 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_128 ] = num_cut_proc;
        edge_cuts[ num_edge_128 ] = num_node_128;
    } else
        num_node_128 = edge_cuts[ num_edge_128 ];
    int num_node_7 = faces.node_lists[ num_face ][ 7 ];
    int min_node_512 = std::min( num_node_7, num_node_0 );
    int max_node_512 = std::max( num_node_7, num_node_0 );
    int num_edge_512 = 64 * max_node_512 + min_node_512;
    int num_node_512;
    if ( edge_num_cut_procs[ num_edge_512 ] != num_cut_proc ) {
        int pos_node;
        if ( available_nodes ) { // there's a node that is going to be freed
            int nn = tzcnt( available_nodes );
            available_nodes -= std::uint64_t( 1 ) << nn;
            
            pos_node = ind_nxt_tmp_node++;
            num_node_512 = nn;
            
            repl_node_dsts[ nb_repl_nodes ] = num_node_512;
            repl_node_srcs[ nb_repl_nodes ] = pos_node;
            ++nb_repl_nodes;
        } else {
            num_node_512 = nodes_size;
            pos_node = nodes_size++;
        }
        const Node &n0 = nodes.local_at( num_node_7 );
        const Node &n1 = nodes.local_at( num_node_0 );
        nodes.local_at( pos_node ).set_pos( n0.pos() + n0.d / ( n0.d - n1.d ) * ( n1.pos() - n0.pos() ) );
        edge_num_cut_procs[ num_edge_512 ] = num_cut_proc;
        edge_cuts[ num_edge_512 ] = num_node_512;
    } else
        num_node_512 = edge_cuts[ num_edge_512 ];
    prev_cut_nodes[ num_node_512 ] = num_node_128;
    last_cut_node = num_node_512;
    // 512,0,128
    faces.nb_nodes[ num_face ] = 3;
    faces.node_lists[ num_face ][ 1 ] = num_node_128;
    faces.node_lists[ num_face ][ 2 ] = num_node_512;
    faces.node_masks[ num_face ] = 
        ( std::uint64_t( 1 ) << num_node_0 ) |
        ( std::uint64_t( 1 ) << num_node_128 ) |
        ( std::uint64_t( 1 ) << num_node_512 ) ;
    return;
}
case_8: {
    // remove face
    faces_to_rem[ nb_faces_to_rem++ ] = num_face;
    faces.node_masks[ num_face ] = 0; // to say that this face is free
    return;
}
case_0:
    // generic case
    ;

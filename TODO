Optimisations à tester:
  => pour les petits nombres de noeuds, ont fait x et y dans les mêmes registres

Prop: on fait un pool pour les points
  => x[ 64*i : 64*i+64 ] // TF 
  => y[ 64*i : 64*i+64 ] // TF
  => z[ 64*i : 64*i+64 ] // TF
  => a[ 64*i : 64*i+64 ] // bool
  => edge0[ ... ]
  => edge1[ ... ]
  => edge2[ ... ]
  => ...

Besoin d'un pool. Pour le 2D, on n'a pas besoin ni de pointeur, ni d'index.

Pour le 3D, on peut utiliser des index voire des pointeurs globaux.

Rq: si on compacte avec du int64 pour les bools, on ne pourra pas utiliser de pointeur dans les noeuds.

Prop: on stocke les angles  


L'hypothèse, c'est qu'on référence des noeuds qui sont sortis de la liste.

=> suppression des noeuds inutiles

Pb d'une z-grille pour le récursif: pour chaque cellule qui contient des sous cellules, on a besoin d'une liste d'in    dices des sous cellules

Est-ce qu'on pourrait faire msi_info en parallèle ?
Algo séquentiel => pour chaque cellule, on regarde son niveau de rafinnement et le nombre de 0. Ça donne le nombre d'info multi-échelle. Pour chaque sous-échelle, 
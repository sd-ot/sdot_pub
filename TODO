Rq: 97% des faces ont nb_nodes <= 8 (en 3D)
Rq: 66% des cellules ont nb_nodes <= 8 dans toutes les faces (en 3D)

Stockage des fcell quand elles sont ooc:
  => on a besoin d'un offset.
  => Prop 1: on fait des pointeurs vers des cellules d'un autre type contenant des offsets.
  => Prop 2: ça se passe au niveau des scells. Par exemple, on a un nombre de sous-cellules définies par pointeur, et un nombre de sous-cellules définies
    par offset.

  Du coup, on pourrait faire des scell avec:
    uint8 => nb enfants type scell (en mémoire)
    uint8 => nb enfants type fcell (en mémoire)
    uint8 => nb enfants type sur le disque.

  Chaque enfant est ou bien un ptr sur fcell, un ptr sur scell ou un offset dans les fichiers de sauvegarde

  Si on a un soucis sur la taille mémoire, on peut parcourir toutes les scells enregistrées comme contenant au moins une fcell.
    on stocke les fcells et on met les offsets 

  Quand on tombe sur des cellules sur le disque, on peut garder la scell en ptr de ce qu'il faut lire.

Prop: on fait une pausounette

Le désavantage des types séparés, c'est que ça complique les tas, les chemins, etc...

Si on a trop de cellules finale... Prop: on parcourt toutes les cellules qui contiennent des fcells pour les mettre en mémoire.

Pour faire simple, on peut faire un parcourt systématique. En deuxième approche, on pourrait stocker le chemin d'accès du dernier. Rq: on peut atteindre les cellules par numéro... mais c'est quand le graphe est construit.

Prop: on fait une liste chainée de cellules finales pour la première allocation. Pour le remplacement dans les scells... on peut de la même façon faire un pointeur vers les parents..
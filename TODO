Rq: 97% des faces ont nb_nodes <= 8 (en 3D)
Rq: 66% des cellules ont nb_nodes <= 8 dans toutes les faces (en 3D)

Assignation des nouveaux noeuds.

Prop 1: on fait une liste de correspondances ancien numéro => nouveau numéro.

Prenant une liste de bits, on veut une liste d'offsets.


Prop: pour savoir où seront placés les nouveaux noeuds, on se base sur ou.

Avec `ou`, on alloue des numéros pour le remplacement des noeuds.
  Si `ou != 0`, on met le nouveau noeud dans une zone temporaire (partant de la fin).


* bornages
  Pb: on veut éviter de faire des undo... 
    Dans handle_intersected_face, on peut créer de nouveaux noeuds et dépasser la limite. On peut aussi créer des faces avec trop de noeuds et dépasser la limite.
    Lors de la création de la nouvelle face, on peut aussi dépasser la limite.

  Prop: on fait des listes de noeuds supplémentaires
* Optimisations dans le code généré.
  => création du masque avec update si c'est plus rapide comme ça.

* Gestion du cas où il y a moins de noeuds à la fin (déplacement des noeuds puis réécriture dans les faces)

LT64 c0;
int s = c0.plane_cut( ..., nb_cuts );
if ( s < nb_cuts ) {
  MT64 c1( c0 );
  s = c1.plane_cut( ..., nb_cuts. );
}

* Optimisations
* Gestion des cas > 64, > 16, ...
  Quel est le nombre max de noeuds qu'on peut créer à partir de 64 noeuds ?
   => chaque noeuds est exactement à 3 autres noeuds. Max nb edges avec coupe = 3 * nb_noeud_dehors.
  Max nb noeuds à la fin = ( 64 - nb_noeud_dehors ) + 3 * nb_noeud_dehors = 64 + 2 * nb_noeud_dehors

  Prop: 



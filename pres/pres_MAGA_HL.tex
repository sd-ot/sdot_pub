\documentclass[aspectratio=169]{beamer}
\setbeamertemplate{navigation symbols}{} % don't use navigation tools on slides
% \usetheme{LMT}

\usepackage[utf8]{inputenc}
\usepackage{pdfpc-commands}
\usepackage{multimedia}
\usepackage{listings}
\usepackage{pgfplots}
\usepackage{default}
\usepackage{xcolor}

\setbeamersize{text margin left=0.6cm,text margin right=0.6cm}
\setbeamercolor{frametitle}{fg=black}
\setbeamercolor{section in toc}{fg=black}
\setbeamertemplate{frametitle}{\color{black}\bfseries\insertframetitle\par\vskip-6pt{\color{gray}\hrulefill}}

\lstset{language=C++,
  basicstyle=\ttfamily,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color{green}\ttfamily,
  morecomment=[l][\color{magenta}]{\#}
}

\AtBeginSection[]{
  \begin{frame}{Summary}
    \tableofcontents[currentsection]
  \end{frame} 
}

\begin{document}

\begin{frame}
    \begin{center}
        {\huge High Performance Computing of Power Diagrams}

        \bigskip
        {\large Applications to Semi-Discrete Optimal Transport}
      
        \vfill
        {(MAGA days, November 21, 2019, Hugo Leclerc)}
    \end{center}
\end{frame}

% ---------------------------------------------------------------------------------------
\section*{Introduction}

\begin{frame}
    \frametitle{The world needs power diagrams !}

    \begin{minipage}[c][0.6\textheight][c]{0.5\textwidth}
        Optimal way to transport a density to a set of diracs (equal mass) ? 
        
        \vfill
        Quadratic cost (euclidian distance) $\Rightarrow$ \textit{attributions} are defined by power diagrams !
        
        \vfill
        $x \in$ cell $i$ if $\forall j \neq i$,
         $$|| x - \rho_i ||^2 - \omega_i < || x - \rho_j ||^2 - \omega_j $$
    \end{minipage}
    \kern 0.5cm
    \begin{minipage}{0.45\textwidth}
        \begin{center}
            \includegraphics[height=0.8\textheight]{img/pd.png}
        \end{center}
    \end{minipage}
\end{frame}

\begin{frame}
    \frametitle{The world needs efficient power diagram computations !}

    Lot of work done before (Geogram, CGAL, ...), with a focus on the generic case.
    
    \vfill
    Most of the libraries are designed to give an \textit{exact connectivity}
    \begin{itemize}
        \item extra CPU and memory cost (bookkeeping)
        \item essentially sequential
    \end{itemize}

    \vfill
    SDOT application being more relaxed (need for simple integrals)
    \begin{itemize}
        \item development and test opportunities 
        \item scalability
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Individual cell computation}

    For each dirac $i$:
    \begin{itemize}
        \item starting from a non void finite cell (typically the domain boundaries),
        \item try some cuts with some \textit{close} diracs $j$
            \hfill{\textcolor{gray}{$\rightarrow$ Cell cuts}}

        \item until not possible to modify the cell
            \hfill{\textcolor{gray}{$\rightarrow$ Acceleration structures}}
    \end{itemize}
    
    \vfill
    Choices:
    \begin{itemize}
        \item infinite cells are handled by exceptions,
        \item tolerance on connectivity discrepancies (if zero mass),
        \item the sets of $j$ to test for a given $i$ are dynamic (dep. on updated cell geometry)
    \end{itemize}
    
\end{frame}

% ---------------------------------------------------------------------------------------
\section{Cell cuts}

\begin{frame}
    \frametitle{A word on test cases}

    Distributions
    \begin{itemize}
        \item uniform in $[0,1]^{dim}$,
        \item uniform in the faces of a VoronoÃ¯ diagram with a fixed number of points (20),
    \end{itemize}

    \begin{center}
        \input{img/voro_distrib.tex}
        \kern 1cm
        \includegraphics[width=0.26\textwidth]{img/voro_distrib_3d.png}
    \end{center}


    \vfill
    Focus on the time to construct the cells.
\end{frame}

\begin{frame}
    \frametitle{Distribution of $\#$ nodes per cell before each cut, 2D case}

    \begin{minipage}[c][0.6\textheight][c]{0.4\textwidth}
        \input{img/nb_nodes_before_cut_2D.tex}
    \end{minipage}
    \kern 0.04\textwidth
    \begin{minipage}{0.55\textwidth}
        \begin{itemize}
            \item Before the cuts, most of the cells have less than 8 nodes
            
            \bigskip
            \item With SIMD instructions, testing all the nodes at once will
                  always be faster than selective testing. 
                  \\ \hfill {\textcolor{gray}{$\Rightarrow$ \texttt{\_mm512\_cmp\_pd\_mask} or similar}}
                  \\ \hfill {\textcolor{gray}{with a struct of aligned blocks}}
              \end{itemize}
    \end{minipage}
\end{frame}

\begin{frame}
    \frametitle{Distribution of $\#$ outside nodes during each cut, 2D case}

    \begin{minipage}[c][0.6\textheight][c]{0.4\textwidth}
        \input{img/nb_outside_2D.tex}
    \end{minipage}
    \kern 0.04\textwidth
    \begin{minipage}{0.55\textwidth}
        \begin{itemize}
            \item Need for quick eviction of the no-cut case.
            
            \bigskip
            \item The number of node in / node out combinations will be reasonably limited. 
            \\ \hfill {\textcolor{gray}{$\Rightarrow$ code generation !}}
        \end{itemize}
    \end{minipage}
\end{frame}


\begin{frame}[fragile]
    \frametitle{Code generation for the 2D case}

    Offline optimization (for the vector of booleans, true if outside):
    \begin{itemize}
        \item all the relevant information stay in registers 
              (minimization of load and stores)
        \item minimization of moves (cyclicity) and scalar operations
    \end{itemize}

\begin{footnotesize}
\begin{lstlisting} 
case 1017: { // size=3 outside=...00000000000001 mod=[ 0, 1 ],1,2,[ 0, 2 ]
    size = 4; // we're adding a new node (staying with the same registers)
    ... // a constant to select between original node vs interpolated ones
    __m512i id_0 = _mm512_cvtepu8_epi64( _mm_cvtsi64_si128( 0x9020108ul ) );
    ... // interpolations
    __m128d x_i0 = _mm_set1_pd( x_0 );     // SSE2 is enough to compute 
    __m128d x_i1 = _mm_set_pd( x_2, x_1 ); // them
    __m128d m = _mm_div_pd( d_i0, _mm_sub_pd( d_i1, d_i0 ) );
    __m512d inter_x = _mm512_castpd128_pd512( 
        _mm_sub_pd( x_i0, _mm_mul_pd( m, _mm_sub_pd( x_i1, x_i0 ) ) )
    );
    ... // store within the same registers
    px_0 = _mm512_permutex2var_pd( px_0, id_0, inter_x );
    break;
}
\end{lstlisting}
\end{footnotesize}
\end{frame}

\begin{frame}
    \frametitle{Speedup due to code generation}

    Time per effective cut:

    \medskip
    \begin{center}    
    \begin{tabular}{|l|c|c|}
        \hline
        Method                 & CPU cycles & Speedup    \\
        \hline
        Optimized generic code & 1 s        & 1 $\times$ \\
        Generated AVX512 code  & 1 s        & 1 $\times$ \\
        \hline
    \end{tabular}
    \end{center}
\end{frame}


\begin{frame}
    \frametitle{Distribution of $\#$ nodes per cell before each cut, 3D case}

    \begin{minipage}[c][0.6\textheight][c]{0.4\textwidth}
        \input{img/nb_nodes_before_cut_3D.tex}
    \end{minipage}
    \kern 0.04\textwidth
    \begin{minipage}{0.55\textwidth}
        \begin{itemize}
            \item Most of the cells have less than 32 nodes.
            \\ \hfill {\textcolor{gray}{$\Rightarrow$ struct of aligned blocks}}

            \bigskip
            \item SIMD still competitive (better to evaluate all at once than test which one
                  to evaluate)
        \end{itemize}
    \end{minipage}
\end{frame}

\begin{frame}
    \frametitle{Distribution of $\#$ outside nodes during each cut, 3D case}

    \begin{minipage}[c][0.6\textheight][c]{0.4\textwidth}
        \input{img/nb_outside_3D.tex}
    \end{minipage}
    \kern 0.04\textwidth
    \begin{minipage}{0.55\textwidth}
        \begin{itemize}
            \item Majority of small cuts

            \bigskip
            \item OK to test all the nodes (in/out), but not each face (rem/cut/in).

            \bigskip
            \item OK for a switch/case for each face with a cut but not for the whole cell.
        \end{itemize}
    \end{minipage}
\end{frame}


\begin{frame}[fragile]
    \frametitle{Structures for 3D cells (simplified)}

    \begin{footnotesize}
    \begin{lstlisting} 
struct NodeBlock {
    Scalar x            [ 64 ]; // struct of block (SIMD)
    Scalar y            [ 64 ]; // sizeof( Scalar ) == sizeof( Edge )
    Scalar z            [ 64 ]; // sizeof( Scalar ) == sizeof( Face * )
    Edge   next_in_faces[ 64 ][ 3 ]; // exactly 3 edges per node 
    Edge   sibling_edges[ 64 ][ 3 ]; // sames edges, in reverse order
    Face  *faces        [ 64 ][ 3 ]; // sizeof( double )
};
struct Edge {
    NodeBlock *nptr_with_offset; // pointer + int in { 0, 1, 2 }
};
struct Face {
    Edge   first_edge; // linked list
    uint64 num_cut;    // to known if already visited
};
struct Cell {
    Pool<Face> faces;  // to have pointer stability
    NodeBlock *nodes;  // aligned
    uint64     nb_cut; // compared to face->num_cut
};
    \end{lstlisting}
    \end{footnotesize}
\end{frame}

\begin{frame}
    \frametitle{Cut procedure}

    \begin{itemize}
        \item Batch eval of the distances node / plane
        \item For each outside node, for each not yet traversed connected face
        \item \ \kern 2mm Add/retrieve node for each in/out edge, assign to edge number 0/1
        \item \ \kern 2mm Remove outside faces
        \item Create a new face, edge number 2
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Speedup / vector version (Face, Edge, Node)}

    Time per effective cut:

    \medskip
    \begin{center}    
    \begin{tabular}{|l|c|c|}
        \hline
        Method                   & CPU cycles & Speedup    \\
        \hline
        vec of structs           & 1 s        & 1 $\times$ \\
        Struct of compact blocks & 1 s        & 1 $\times$ \\
        \hline
    \end{tabular}
    \end{center}
\end{frame}

% ---------------------------------------------------------------------------------------
\section{Acceleration structures}

\begin{frame}
    \frametitle{Algorithmic complexity}

    $\forall\ i, j \neq i $ basically gives $ \mathcal{O}( n^2 )$... would be far behind the 
      expected $\mathcal{O}( n \log{}n )$
    
    But only a small neighborhood is actually needed !

    \begin{itemize}
        \item A given radius around each dirac works very well for isotropic cells
        \item For highly anisotropic or not regular cases, new algorithms remained to be tested.
    \end{itemize}
\end{frame}


% ---------------------------------------------------------------------------------------
\section{Product placement}


% ---------------------------------------------------------------------------------------
\section{Conclusions}

\begin{frame}
    \frametitle{Conclusions}

    Smurf
    \begin{itemize}
        \item ...
    \end{itemize}
    
    \vfill
\end{frame}


\begin{frame}
    \frametitle{Perspectives}

\end{frame}


\end{document}
